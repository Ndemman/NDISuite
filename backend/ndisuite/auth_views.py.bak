"""Authentication-related API views.
This module contains registration, login, and email verification endpoints that use 
Django's built-in User model. Email verification is required to activate new accounts.

If/when a more sophisticated auth system is introduced (JWT, social auth, etc.)
this file can either be expanded or replaced with a dedicated Django app."""
import logging
import traceback
import uuid
import json
import requests
from datetime import datetime, timedelta
from urllib.parse import urlencode
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from django.db import connection, OperationalError, transaction
from django.conf import settings
from django.template.loader import render_to_string
from django.core.mail import EmailMultiAlternatives
from django.shortcuts import redirect
from rest_framework import serializers, status, permissions
from rest_framework.response import Response
from rest_framework.views import APIView
import random
import string
import secrets
import string
import hashlib
from django.core.cache import cache
from .models import EmailVerificationToken, PasswordResetToken, SocialAccount
from .jwt_utils import generate_jwt_token
from .rate_limiting import rate_limit
from .domain_validation import is_allowed_email_domain
from .oauth_utils import extract_email_from_oauth_data

# Configure logging
logger = logging.getLogger('ndisuite')


class RegisterSerializer(serializers.Serializer):
    """Validate and create a new Django User instance with email verification."""

    email = serializers.EmailField()
    first_name = serializers.CharField(max_length=150)
    last_name = serializers.CharField(max_length=150)
    password = serializers.CharField(write_only=True, min_length=8)
    password_confirm = serializers.CharField(write_only=True, min_length=8)

    # Extra fields coming from the frontend. We store them for now so that the
    # serializer does not raise an unknown-field error. They are *not* persisted
    # because the default User model has nowhere to put them, but capturing them
    # here gives us forward-compatibility once a profile model is added.
    account_type = serializers.ChoiceField(
        choices=["PARENT", "CHILD", "LONE"], required=False, allow_blank=True
    )
    organization = serializers.CharField(required=False, allow_blank=True, max_length=255)
    job_title = serializers.CharField(required=False, allow_blank=True, max_length=255)

    def validate_email(self, value: str) -> str:
        try:
            # Check if the auth_user table exists by running a simple query
            with connection.cursor() as cursor:
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='auth_user'")
                if not cursor.fetchone():
                    # If table doesn't exist, log this and just return the value
                    # This will be handled properly in the create method
                    logger.warning("auth_user table does not exist")
                    return value
                
            # If we get here, the table exists, so check for existing user
            if User.objects.filter(email=value).exists():
                raise serializers.ValidationError("A user with this email already exists.")
            return value
        except Exception as e:
            logger.error(f"Error in validate_email: {str(e)}")
            # Return the value and handle the error in create method
            return value

    def validate(self, attrs):
        if attrs.get("password") != attrs.get("password_confirm"):
            raise serializers.ValidationError({"password_confirm": "Passwords do not match."})
        return attrs
    
    def send_verification_email(self, user, token):
        """Send verification email to newly registered user."""
        verification_url = f"{settings.FRONTEND_URL}/verify-email/{token.token}"
        
        # Load email templates
        context = {
            'user': user,
            'verification_url': verification_url
        }
        
        subject = "Verify your NDISuite account"
        from_email = settings.DEFAULT_FROM_EMAIL
        to_email = user.email
        
        # Send email with both HTML and plain text versions
        html_content = render_to_string('email/verification_email.html', context)
        text_content = render_to_string('email/verification_email.txt', context)
        
        msg = EmailMultiAlternatives(subject, text_content, from_email, [to_email])
        msg.attach_alternative(html_content, "text/html")
        
        try:
            msg.send()
            logger.info(f"Verification email sent to {user.email}")
        except Exception as e:
            logger.error(f"Failed to send verification email: {str(e)}\n{traceback.format_exc()}")
            # Don't block registration if email fails

    def create(self, validated_data):
        # Remove fields that do not exist on the User model
        validated_data.pop("password_confirm", None)
        account_type = validated_data.pop("account_type", None)
        validated_data.pop("organization", None)
        validated_data.pop("job_title", None)

        # Use the email as the username for simplicity
        validated_data["username"] = validated_data["email"]
        
        # Set user as inactive until email verification
        validated_data["is_active"] = False

        password = validated_data.pop("password")
        try:
            # Create the user
            user = User.objects.create_user(password=password, **validated_data)
            
            # Generate verification token
            token = EmailVerificationToken.objects.create(user=user)
            
            # Send verification email
            self.send_verification_email(user, token)
            
            return user
        except Exception as e:
            logger.error(f"Error creating user: {str(e)}\n{traceback.format_exc()}")
            raise serializers.ValidationError(f"Could not create user: {str(e)}")


class RegisterView(APIView):
    """POST /api/v1/auth/register/ to create a new user account."""

    # Anyone can access the registration endpoint.
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        try:
            serializer = RegisterSerializer(data=request.data)
            if serializer.is_valid():
                user = serializer.save()
                
                # Handle both User model instances and dictionary results
                if isinstance(user, dict):
                    # Already formatted as a dict with the right fields
                    data = user
                else:
                    # Standard User model instance
                    data = {
                        "id": user.id,
                        "email": user.email,
                        "first_name": user.first_name,
                        "last_name": user.last_name,
                    }
                
                return Response(data, status=status.HTTP_201_CREATED)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger.error(f"Unhandled exception in registration: {str(e)}\n{traceback.format_exc()}")
            # Return a friendly error message
            return Response(
                {"detail": "Registration service is temporarily unavailable. Please try again later."},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class LoginSerializer(serializers.Serializer):
    """Validate user credentials and authenticate."""
    email = serializers.EmailField()
    password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        
        try:
            # First check if user exists but is inactive
            user = User.objects.get(email=email)
            if not user.is_active:
                raise serializers.ValidationError(
                    "Your account is not activated. Please check your email for the verification link or request a new one."
                )
                
            # Then attempt authentication
            user = authenticate(username=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password.")
                
            attrs["user"] = user
            return attrs
        except User.DoesNotExist:
            # Just attempt authentication which will fail with wrong credentials
            user = authenticate(username=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password.")
            
            attrs["user"] = user
            return attrs


class LoginView(APIView):
    """POST /api/v1/auth/login/ to authenticate user credentials."""
    permission_classes = [permissions.AllowAny]

    def post(self, request):
        try:
            # Process login with database authentication
            serializer = LoginSerializer(data=request.data)
            if serializer.is_valid():
                user = serializer.validated_data["user"]
                # Dummy tokens for development; replace with real JWT later
                tokens = {
                    "access": "dev-access-token",
                    "refresh": "dev-refresh-token",
                }
                data = {
                    "tokens": tokens,
                    "user": {
                        "id": user.id,
                        "email": user.email,
                        "first_name": user.first_name,
                        "last_name": user.last_name,
                        "is_active": user.is_active,
                    },
                }
                return Response(data, status=status.HTTP_200_OK)
            return Response(serializer.errors, status=status.HTTP_401_UNAUTHORIZED)
        except Exception as e:
            logger.error(f"Unhandled exception in login: {str(e)}\n{traceback.format_exc()}")
            # Return a friendly error message
            return Response(
                {"detail": "Login service is temporarily unavailable. Please try again later."},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class VerifyEmailView(APIView):
    """GET /api/v1/auth/verify-email/<token>/ to verify user email and activate account."""
    permission_classes = [permissions.AllowAny]
    
    def get(self, request, token):
        try:
            # Convert string token to UUID
            token_uuid = uuid.UUID(token)
            token_obj = EmailVerificationToken.objects.get(token=token_uuid)
            
            if not token_obj.is_valid():
                return Response(
                    {"detail": "Verification link has expired or already been used."}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Activate user
            user = token_obj.user
            user.is_active = True
            user.save()
            
            # Mark token as used
            token_obj.is_used = True
            token_obj.save()
            
            # Prepare response data with user info and tokens for auto-login
            tokens = {
                "access": "dev-access-token",  # Replace with real JWT generation
                "refresh": "dev-refresh-token", # Replace with real JWT generation
            }
            
            data = {
                "detail": "Email verified successfully",
                "tokens": tokens,
                "user": {
                    "id": user.id,
                    "email": user.email,
                    "first_name": user.first_name,
                    "last_name": user.last_name,
                    "is_active": user.is_active,
                }
            }
            
            return Response(data, status=status.HTTP_200_OK)
            
        except (ValueError, EmailVerificationToken.DoesNotExist):
            return Response(
                {"detail": "Invalid verification link."}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(f"Email verification error: {str(e)}\n{traceback.format_exc()}")
            return Response(
                {"detail": "Verification failed due to an error."}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class ResendVerificationEmailView(APIView):
    """POST /api/v1/auth/resend-verification/ to resend verification email."""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        email = request.data.get('email')
        if not email:
            return Response(
                {"detail": "Email is required."}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            user = User.objects.get(email=email, is_active=False)
            
            # Check for existing tokens and invalidate them
            existing_tokens = EmailVerificationToken.objects.filter(
                user=user, is_used=False
            )
            for token in existing_tokens:
                token.is_used = True
                token.save()
            
            # Create new token
            new_token = EmailVerificationToken.objects.create(user=user)
            
            # Send verification email
            serializer = RegisterSerializer()
            serializer.send_verification_email(user, new_token)
            
            return Response(
                {"detail": "Verification email resent successfully."}, 
                status=status.HTTP_200_OK
            )
            
        except User.DoesNotExist:
            # Don't reveal if user exists for security
            return Response(
                {"detail": "If your email exists in our system, a verification email has been sent."}, 
                status=status.HTTP_200_OK
            )
        except Exception as e:
            logger.error(f"Resend verification error: {str(e)}\n{traceback.format_exc()}")
            return Response(
                {"detail": "Failed to resend verification email."}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class RequestPasswordResetSerializer(serializers.Serializer):
    """Validate email for password reset request."""
    email = serializers.EmailField()


class RequestPasswordResetView(APIView):
    """POST /api/v1/auth/request-password-reset/ to request a password reset email."""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = RequestPasswordResetSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        email = serializer.validated_data['email']
        
        try:
            # Find user by email
            try:
                user = User.objects.get(email=email)
            except User.DoesNotExist:
                # Don't reveal if user exists for security
                return Response(
                    {"detail": "If your email exists in our system, a password reset link has been sent."}, 
                    status=status.HTTP_200_OK
                )
            
            # User exists - invalidate any existing tokens
            from .models import PasswordResetToken
            existing_tokens = PasswordResetToken.objects.filter(
                user=user, is_used=False
            )
            for token in existing_tokens:
                token.is_used = True
                token.save()
            
            # Create a password reset token
            reset_token = PasswordResetToken.objects.create(user=user)
        
            # Generate the reset URL (frontend URL with token)
            reset_url = f"{settings.FRONTEND_URL}/auth/password-reset-confirm?token={reset_token.token}"
            
            # Prepare email context
            context = {
                'user': user,
                'reset_url': reset_url
            }
            
            # Send email
            subject = "Reset your NDISuite password"
            from_email = settings.DEFAULT_FROM_EMAIL
            to_email = user.email
            
            html_content = render_to_string('email/password_reset_email.html', context)
            text_content = render_to_string('email/password_reset_email.txt', context)
            
            msg = EmailMultiAlternatives(subject, text_content, from_email, [to_email])
            msg.attach_alternative(html_content, "text/html")
            msg.send()
            
            return Response(
                {"detail": "If your email exists in our system, a password reset link has been sent."}, 
                status=status.HTTP_200_OK
            )
            
        except Exception as e:
            logger.error(f"Password reset request error: {str(e)}\n{traceback.format_exc()}")
            return Response(
                {"detail": "Failed to process password reset request."}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class PasswordResetSerializer(serializers.Serializer):
    """Validate new password for reset."""
    password = serializers.CharField(min_length=8, write_only=True)
    password_confirm = serializers.CharField(min_length=8, write_only=True)
    
    def validate(self, attrs):
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({"password_confirm": "Passwords do not match."})
        return attrs


class PasswordResetView(APIView):
    """POST /api/v1/auth/reset-password/<token>/ to reset user password."""
    permission_classes = [permissions.AllowAny]
    
    def post(self, request, token):
        serializer = PasswordResetSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            # Validate token
            from .models import PasswordResetToken
            token_uuid = uuid.UUID(token)
            token_obj = PasswordResetToken.objects.get(token=token_uuid)
            
            if not token_obj.is_valid():
                return Response(
                    {"detail": "Password reset link has expired or already been used."}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Update user password
            user = token_obj.user
            user.set_password(serializer.validated_data['password'])
            user.save()
            
            # Mark token as used
            token_obj.is_used = True
            token_obj.save()
            
            # Return success response
            return Response(
                {"detail": "Password has been reset successfully. You can now log in with your new password."}, 
                status=status.HTTP_200_OK
            )
            
        except (ValueError, PasswordResetToken.DoesNotExist):
            return Response(
                {"detail": "Invalid password reset link."}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            logger.error(f"Password reset error: {str(e)}\n{traceback.format_exc()}")
            return Response(
                {"detail": "Failed to reset password due to an error."}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


# Social Authentication Views

class GoogleOAuthInitView(APIView):
    """Initiate OAuth flow for Google authentication."""
    permission_classes = [permissions.AllowAny]
    
    @rate_limit(key_prefix='oauth_google_init', limit=5, period=60)
    def get(self, request):
        # Create the authorization URL for Google OAuth 2.0
        auth_params = {
            'client_id': settings.GOOGLE_OAUTH_CLIENT_ID,
            'redirect_uri': settings.GOOGLE_OAUTH_REDIRECT_URI,
            'scope': ' '.join(settings.GOOGLE_OAUTH_SCOPES),
            'response_type': 'code',
            'access_type': 'offline',  # Get refresh token
            'prompt': 'consent'  # Always show consent screen
        }
        
        # Generate and store a secure state parameter for CSRF protection
        # First, check if client sent a state parameter
        client_state = request.GET.get('state', '')
        
        # Generate a secure server-side state token
        server_state = secrets.token_hex(16)
        
        # Combine client state (if provided) with server state
        combined_state = f"{server_state}:{client_state}" if client_state else server_state
        
        # Create a hash of the combined state to use as the cache key
        state_hash = hashlib.sha256(combined_state.encode()).hexdigest()
        
        # Store in cache with 15-minute expiration
        cache.set(f"oauth_state:{state_hash}", combined_state, 60 * 15)  # 15 minutes
        
        # Add state to auth params
        auth_params['state'] = state_hash
            
        # Redirect to Google's OAuth consent screen
        auth_url = f"https://accounts.google.com/o/oauth2/v2/auth?{urlencode(auth_params)}"
        return redirect(auth_url)


class GoogleOAuthCallbackView(APIView):
    """Handle callback from Google OAuth flow."""
    permission_classes = [permissions.AllowAny]
    
    @rate_limit(key_prefix='oauth_google_callback', limit=10, period=60)
    def get(self, request):
        try:
            # Get authorization code and state parameter from callback
            code = request.GET.get('code')
            state = request.GET.get('state')
            
            if not code:
                return Response({"error": "Authorization code not provided"},
                              status=status.HTTP_400_BAD_REQUEST)
            
            if not state:
                logger.error("OAuth callback missing state parameter")
                return redirect(f"{settings.FRONTEND_URL}/auth/login?error=invalid_state")
            
            # Validate state parameter to prevent CSRF attacks
            stored_state = cache.get(f"oauth_state:{state}")
            if not stored_state:
                logger.error(f"Invalid or expired OAuth state: {state}")
                return redirect(f"{settings.FRONTEND_URL}/auth/login?error=invalid_state")
            
            # State is valid, delete it from cache to prevent replay attacks
            cache.delete(f"oauth_state:{state}")
            
            # Extract client state if it was provided
            client_state = ""
            if ":" in stored_state:
                _, client_state = stored_state.split(":", 1)
            
            # Exchange code for access token
            token_data = self._exchange_code_for_token(code)
            if 'error' in token_data:
                return Response(token_data, status=status.HTTP_400_BAD_REQUEST)
                
            # Get user information using access token
            user_info = self._get_user_info(token_data['access_token'])
            if 'error' in user_info:
                return Response(user_info, status=status.HTTP_400_BAD_REQUEST)
            
            # Get email from user info (Microsoft uses different fields)
            user_email = None
            if 'mail' in user_info and user_info['mail']:
                user_email = user_info['mail']
            elif 'userPrincipalName' in user_info and user_info['userPrincipalName']:
                user_email = user_info['userPrincipalName']
                
            # Validate email domain if enabled
            if settings.ENFORCE_EMAIL_DOMAIN_RESTRICTIONS and user_email:
                if not is_allowed_email_domain(user_email, 'microsoft'):
                    logger.warning(f"Blocked login attempt from unauthorized domain: {user_email}")
                    return redirect(f"{settings.FRONTEND_URL}/auth/login?error=domain_not_allowed")
                
            # Sign in or sign up the user
            result = self._authenticate_user(user_info, token_data)
            
            # Redirect back to frontend with auth token and client state (if any)
            redirect_url = f"{settings.FRONTEND_URL}/auth/social-callback?token={result['token']}"
            if 'is_new_user' in result and result['is_new_user']:
                redirect_url += "&is_new_user=true"
            
            # Pass client state back to frontend if it was provided
            if client_state:
                redirect_url += f"&state={client_state}"
                
            return redirect(redirect_url)
            
        except Exception as e:
            logger.error(f"Google OAuth callback error: {str(e)}\n{traceback.format_exc()}")
            return redirect(f"{settings.FRONTEND_URL}/auth/login?error=google_auth_failed")
            
    def _exchange_code_for_token(self, code):
        """Exchange authorization code for access token."""
        token_url = "https://oauth2.googleapis.com/token"
        payload = {
            'client_id': settings.GOOGLE_OAUTH_CLIENT_ID,
            'client_secret': settings.GOOGLE_OAUTH_CLIENT_SECRET,
            'code': code,
            'grant_type': 'authorization_code',
            'redirect_uri': settings.GOOGLE_OAUTH_REDIRECT_URI
        }
        
        response = requests.post(token_url, data=payload)
        if response.status_code != 200:
            logger.error(f"Google token exchange error: {response.text}")
            return {"error": "Failed to exchange code for token"}
            
        return response.json()
    
    def _get_user_info(self, access_token):
        """Get user info from Google using access token."""
        user_info_url = "https://www.googleapis.com/oauth2/v3/userinfo"
        headers = {"Authorization": f"Bearer {access_token}"}
        
        response = requests.get(user_info_url, headers=headers)
        if response.status_code != 200:
            logger.error(f"Google user info error: {response.text}")
            return {"error": "Failed to get user information"}
            
        return response.json()
    
    def _authenticate_user(self, user_info, token_data):
        """Sign in or create a user based on Google profile information."""
        is_new_user = False
        
        # Check for required fields from Google
        if not user_info.get('sub') or not user_info.get('email'):
            raise ValueError("Missing required user information from Google")
            
        # Check if a social account already exists for this Google ID
        try:
            social_account = SocialAccount.objects.get(
                provider='google',
                provider_user_id=user_info['sub']
            )
            
            # Update token information
            social_account.access_token = token_data.get('access_token', '')
            if 'refresh_token' in token_data:
                social_account.refresh_token = token_data['refresh_token']
                
            if 'expires_in' in token_data:
                social_account.token_expires_at = datetime.now() + timedelta(seconds=token_data['expires_in'])
                
            # Update user info
            social_account.first_name = user_info.get('given_name', '')
            social_account.last_name = user_info.get('family_name', '')
            social_account.profile_picture = user_info.get('picture', '')
            social_account.set_extra_data(user_info)
            social_account.save()
            
            # Get the Django user
            user = social_account.user
            
        except SocialAccount.DoesNotExist:
            # No social account exists, check if a user with this email exists
            with transaction.atomic():
                try:
                    user = User.objects.get(email=user_info['email'])
                except User.DoesNotExist:
                    # Create a new user
                    user = User.objects.create_user(
                        username=user_info['email'],  # Use email as username
                        email=user_info['email'],
                        first_name=user_info.get('given_name', ''),
                        last_name=user_info.get('family_name', ''),
                    )
                    
                    # Set a random password (user won't need it with social auth)
                    random_password = User.objects.make_random_password()
                    user.set_password(random_password)
                    user.save()
                    
                    # Mark as a new user for frontend to potentially show onboarding
                    is_new_user = True
                    
                # Create social account
                social_account = SocialAccount.objects.create(
                    user=user,
                    provider='google',
                    provider_user_id=user_info['sub'],
                    email=user_info['email'],
                    first_name=user_info.get('given_name', ''),
                    last_name=user_info.get('family_name', ''),
                    profile_picture=user_info.get('picture', ''),
                    access_token=token_data.get('access_token', ''),
                    refresh_token=token_data.get('refresh_token', ''),
                )
                
                if 'expires_in' in token_data:
                    social_account.token_expires_at = datetime.now() + timedelta(seconds=token_data['expires_in'])
                
                social_account.set_extra_data(user_info)
                social_account.save()
                
        # Ensure the user is active
        if not user.is_active:
            user.is_active = True
            user.save()
            
        # Create secure JWT token for the user
        token = generate_jwt_token(
            user_id=user.id,
            user_email=user.email,
            is_new_user=is_new_user
        )
            
        return {
            'token': token,
            'user_id': user.id,
            'email': user.email,
            'is_new_user': is_new_user
        }


class GoogleOAuthInitView(APIView):
    """Initiate OAuth flow for Google authentication."""
    permission_classes = [permissions.AllowAny]
    
    @rate_limit(key_prefix='oauth_google_init', limit=5, period=60)
    def get(self, request):
        # Create the authorization URL for Google OAuth 2.0
        auth_params = {
            'client_id': settings.GOOGLE_OAUTH_CLIENT_ID,
            'redirect_uri': settings.GOOGLE_OAUTH_REDIRECT_URI,
            'scope': ' '.join(settings.GOOGLE_OAUTH_SCOPES),
            'response_type': 'code',
            'response_mode': 'query'
        }
        
        # Generate and store a secure state parameter for CSRF protection
        # First, check if client sent a state parameter
        client_state = request.GET.get('state', '')
        
        # Generate a secure server-side state token
        server_state = secrets.token_hex(16)
        
        # Combine client state (if provided) with server state
        combined_state = f"{server_state}:{client_state}" if client_state else server_state
        
        # Create a hash of the combined state to use as the cache key
        state_hash = hashlib.sha256(combined_state.encode()).hexdigest()
        
        # Store in cache with 15-minute expiration
        cache.set(f"oauth_state:{state_hash}", combined_state, 60 * 15)  # 15 minutes
        
        # Add state to auth params
        auth_params['state'] = state_hash
            
        # Redirect to Google's OAuth consent screen
        auth_url = f"https://accounts.google.com/o/oauth2/v2/auth?{urlencode(auth_params)}"
        return redirect(auth_url)
